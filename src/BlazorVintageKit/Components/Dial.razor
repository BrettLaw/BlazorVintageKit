<svg version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve">


    <!--Outer dial perimeter-->
    <circle cx="50" cy="50" r="@Options.DialRadius" fill="@Options.DialColour" />

    @if (Options.RiskMode)
    {
        <!-- Risk segment -->
        <g transform="translate(50, 50) rotate(@riskRotate)">
            <path d="M 0 0 L @Options.DialRadius 0 A @Options.DialRadius @Options.DialRadius 0 0 1 @segmentArc.Item1 @segmentArc.Item2 Z" fill="@Options.RiskColour" />
        </g>
    }

    <!-- Circle edge colour -->
    <circle cx="50" cy="50" r="@Options.DialRadius" stroke="@Options.RimColour" stroke-width="@Options.RimWidth" fill="none" /> 


    @if (Options.InnerRing)
    {
        <g transform="translate(50, 50) rotate(@rotate)">
            <path d="M 0 -@Options.FaceRadius A @Options.FaceRadius @Options.FaceRadius 0 @arcV.LargeArcFlag @arcV.SweepFlag @arcV.X @arcV.Y" fill="none" stroke="@Options.FaceColour" />
        </g>
    }
    @if (Options.SmithsMode)
    {
        <g transform="translate(50, 50) rotate(@rotate)">

            <path d="M 0 -@(Options.FaceRadius-5) A @(Options.FaceRadius-5) @(Options.FaceRadius-5) 0 @smithsArcV.LargeArcFlag @smithsArcV.SweepFlag @smithsArcV.X @smithsArcV.Y" fill="none" stroke="@Options.FaceColour" />

        </g>
    }

    <!-- combined dial marks-->
    <g transform="translate(50, 50) rotate(@rotate)">
        @for (int i = 0; i <= ((Options.IndicatorCount-1) * (Options.SubIndicatorCount + 1)); i++)
        {
            var anglePerMark = i * perMarkerAngle; // 270 degrees divided by the total number of small intervals
            if (i % (Options.SubIndicatorCount + 1) == 0) // Every 5th mark is a large mark
            {
                <line x1="0" y1="@((Options.FaceRadius-5)*-1)" x2="0" y2="@(Options.FaceRadius*-1)" stroke="@Options.FaceColour" stroke-width="0.5" transform="rotate(@anglePerMark)" />
            }
            else // Small marks
            {
                <line x1="0" y1="@((Options.FaceRadius-Options.SubIndicatorLength)*-1)" x2="0" y2="@((Options.FaceRadius)*-1)" stroke="@Options.FaceColour" stroke-width="0.2" transform="rotate(@anglePerMark)" />
            }
        }
    </g>

    <!-- text labels -->
    <g transform="translate(50, @(50+Options.LabelYOffset))">
        @{
            var angleoffset = (rotate*-1) + charRotation;
            var textoffset = (Options.FaceRadius-10)*-1;

            if (Options.ReverseMode)
            {
                for (int i = 0; i <= (Options.IndicatorCount-1); i++)
                {
                    var angle = angleoffset - i * (Options.FaceArcAngle / (Options.IndicatorCount-1)); // Adjust the angle calculation
                    var radians = angle * Math.PI / 180; // Convert angle to radians
                    var x = textoffset * Math.Sin(radians); // Calculate x position
                    var y = textoffset * Math.Cos(radians); // Calculate y position

                    int k = (Options.IndicatorCount-1) - i;

                    <text><text x="@x" y="@y" style="cursor:default;" font-family="@Options.LabelFont" transform="rotate(@Options.LabelTextRotation @x @(y-(Options.LabelFontSize)))" font-size="@(Options.LabelFontSize)px" text-anchor="middle" fill="@Options.FaceColour">@((k * indicatorRange / 100).ToString())</text></text>
                }
            }
            else
            {
                for (int i = 0; i <= (Options.IndicatorCount-1); i++)
                {
                    var angle = angleoffset - i * (Options.FaceArcAngle / (Options.IndicatorCount-1)); // Adjust the angle calculation
                    var radians = angle * Math.PI / 180; // Convert angle to radians
                    var x = textoffset * Math.Sin(radians); // Calculate x position
                    var y = textoffset * Math.Cos(radians); // Calculate y position

                    <text><text x="@x" y="@y" style="cursor:default;" font-family="@Options.LabelFont" transform="rotate(@Options.LabelTextRotation @x @(y-(Options.LabelFontSize)))" font-size="@(Options.LabelFontSize)px" text-anchor="middle" fill="@Options.FaceColour">@((i * indicatorRange / 100).ToString())</text></text>
                }
            }
            
        }
    </g>

    @if (Options.ResetPointerMode)
    {
        <!-- reset pointer -->
        <g transform="rotate(@rotate 50 50)">
            <polygon points="49.7,@(8 - Options.PointerLengthAdjust) 50.3,@(8 - Options.PointerLengthAdjust) 50.6,@(Options.PointerTailLengthAdjust+65) 49.4,@(Options.PointerTailLengthAdjust+65)" fill="@Options.ResetPointercolour" transform="rotate(@maxPointerAngle 50 50)" id="pointer" />
        </g>
        <g transform="rotate(@Options.AdditionalRotation 50 50)">
            <circle cx="50" cy="90" r="3" stroke-width="2" fill="@Options.ResetButtonColour" @onclick="Reset" style="cursor:pointer;"/>
        </g>
    }


    <!-- pointer -->
    <g transform="rotate(@rotate 50 50)">


            @if(Options.AlternatePointer)
            {
                <polygon points="50,@((Options.FaceRadius*-1)+60) 53,@((Options.FaceRadius*-1)+70) 47,@((Options.FaceRadius*-1)+70)" fill="@Options.Pointercolour" transform="rotate(@pointerAngle 50 50)" id="pointer" />
            }
            else
            {
                <polygon points="49.5,@(8 - Options.PointerLengthAdjust) 50.5,@(8 - Options.PointerLengthAdjust) 51,@(Options.PointerTailLengthAdjust+65) 49,@(Options.PointerTailLengthAdjust+65)" fill="@Options.Pointercolour" transform="rotate(@pointerAngle 50 50)" id="pointer" />
            }


    </g>

    <!--center-->
    @if (!Options.AlternatePointer)
    {
        <circle cx="50" cy="50" r="3" stroke-width="2" fill="@Options.BossColour" />
        <circle cx="50" cy="50" r="1" stroke-width="2" fill="@Options.BossCenterColour" />
    }

    <!-- Text -->
    <g transform="translate(50, 50)">
        <text x="@Options.MakersLabelX" y="@Options.MakersLabelY" font-size="@Options.MakersLabelFontSize" text-anchor="middle" fill="@Options.FaceColour" style="cursor:default;" font-family="@Options.MakersLabelFont">@Options.MakersLabel</text>
        <text x="@Options.KeyLabelX" y="@Options.KeyLabelY" font-size="@Options.KeyLabelFontSize" text-anchor="middle" fill="@Options.FaceColour" style="cursor:default;" font-family="@Options.KeyLabelFont">@Options.KeyLabel</text>
    </g>

</svg>


@code {
    [Parameter] public DialOptions Options { get; set; } = new DialOptions();


    private double rotate = 0;
    private double perMarkerAngle;
    private double totalIndicatorCount;
    private int charRotation = 0;
    private int indicatorRange => Options.DialRange == 0 ? 1 : Options.DialRange / (Options.IndicatorCount-1);
    private (double,double) segmentArc;
    private double riskRotate;

    private double pointerAngle = 0;
    private double maxPointerAngle = 0;
    private double pointerAnglePerIncrement = 0;

    private SVGArc arcV;
    private SVGArc smithsArcV;

    protected override void OnInitialized()
    {
        UpdateValues();
        maxPointerAngle = pointerAngle;
    }

    protected override void OnParametersSet()
    {
        UpdateValues();
    }

    private void UpdateValues()
    {
        smithsArcV = CalculateArcDetails(Options.FaceRadius-5, Options.FaceArcAngle);
        arcV = CalculateArcDetails(Options.FaceRadius, Options.FaceArcAngle);

        rotate = CalcRotation(Options.FaceArcAngle, Options.AdditionalRotation);

        segmentArc = CalculateRiskEndpoint(Options.DialRadius, Options.RiskAngle);

        totalIndicatorCount = ((Options.IndicatorCount-1) * (Options.SubIndicatorCount + 1));
        perMarkerAngle = (Options.FaceArcAngle / totalIndicatorCount);

        pointerAnglePerIncrement = (float)Options.FaceArcAngle / Options.DialRange;

        riskRotate = Options.RiskAdditionalRotation + ((Options.RiskAdditionalRotation + 45 - Options.RiskAngle)) + Options.AdditionalRotation + ((Options.FaceArcAngle - 270) / 2);

        CalcBarValue();
    }

    private void Reset()
    {
        maxPointerAngle = pointerAngle;
    }

    private void CalcBarValue()
    {

        if(Options.ReverseMode)
        {
            var o = Options.FaceArcAngle;

            var j = Options.DialValue * pointerAnglePerIncrement;

            pointerAngle = o - j;
            if (pointerAngle < maxPointerAngle) maxPointerAngle = pointerAngle;
        }
        else
        {
            pointerAngle = Options.DialValue * pointerAnglePerIncrement;
            if (pointerAngle > maxPointerAngle) maxPointerAngle = pointerAngle;
        }




    }

    private static double CalcRotation(double arcAngle, int offsetRotation)
    {
        // Calculate rotation to center missing arc at the bottom
        return 180 + offsetRotation + (360 - arcAngle) / 2;
    }

    public static (double, double) CalculateRiskEndpoint(double radius, double angle)
    {
        double radians = Math.PI * angle / 180.0; // Convert angle to radians
        double x = radius * Math.Cos(radians);    // Calculate x-coordinate
        double y = radius * Math.Sin(radians);    // Calculate y-coordinate
        return (x, y);
    }

    static SVGArc CalculateArcDetails(double radius, double arcAngle)
    {
        int largeArcFlag = arcAngle > 180 ? 1 : 0;
        int sweepFlag = 1;

        (double x, double y) = CalculateArcEndpoint(radius, arcAngle);

        return new SVGArc(x, y, largeArcFlag, sweepFlag);
    }


    static (double, double) CalculateArcEndpoint(double radius, double angleDegrees)
    {
        // Convert angle to radians
        double angleRadians = angleDegrees * Math.PI / 180;

        // Calculate x and y coordinates of the endpoint
        double x = radius * Math.Sin(angleRadians);  // Sin for x
        double y = -radius * Math.Cos(angleRadians); // Cos for y, inverted for SVG's coordinate system

        return (x, y);
    }



}
